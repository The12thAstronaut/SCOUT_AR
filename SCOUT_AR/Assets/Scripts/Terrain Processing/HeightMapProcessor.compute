// Takes raw height map [0, 1] and calculates actual world heights.
// Saves result in texture.

#pragma kernel AssignVertexHeights

Texture2D<float> HeightMap;
SamplerState height_linear_clamp_sampler;
float2 size;
float heightFactor;

float getHeight(float2 uv)
{
    return HeightMap.SampleLevel(height_linear_clamp_sampler, uv, 0);
}

float calculateSmoothHeight(float2 uv)
{
    float2 offset = float2(1, 1) / 3200 * 4.5;
    float h0 = getHeight(uv);

    if (h0 < 0.01)
    {
        return h0;
    }


    float hN = getHeight(uv + float2(0, 1) * offset);
    float hS = getHeight(uv + float2(0, -1) * offset);
    float hW = getHeight(uv + float2(-1, 0) * offset);
    float hE = getHeight(uv + float2(1, 0) * offset);

    float hNE = getHeight(uv + float2(1, 1) * 0.707 * offset);
    float hSW = getHeight(uv + float2(-1, -1) * 0.707 * offset);
    float hNW = getHeight(uv + float2(-1, 1) * 0.707 * offset);
    float hSE = getHeight(uv + float2(1, -1) * 0.707 * offset);
	
	//return h0;
    return lerp(h0, (hN + hS + hW + hE + hNE + hSW + hNW + hSE) / 8.0, 0.35);
}

// ---- Assign vertex heights ----
RWStructuredBuffer<float3> Vertices;
RWStructuredBuffer<float> Heights;
uint numVertices;

// Convert 2D vertices (longitude/latitude coordinates) into 3D vertices (points on sphere)
[numthreads(1024, 1, 1)]
void AssignVertexHeights(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numVertices)
    {
        return;
    }
	
    float3 planePos = Vertices[id.x];
    float2 texCoord = float2(planePos.x / size.x, planePos.z / size.y);
    //float2 texCoord = float2(planePos.x, planePos.z);
    float height = calculateSmoothHeight(texCoord);
    Heights[id.x] = height;
    Vertices[id.x] = Vertices[id.x] + float3(0, heightFactor, 0) * height;
}